/*
 * generated by Xtext 2.15.0
 */
package compilation.generator

import compilation.whileLanguage.Definition
import compilation.whileLanguage.Function
import compilation.whileLanguage.Program
import java.util.Map
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import compilation.whileLanguage.Commands
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhileLanguageGenerator extends AbstractGenerator {
	//en fait c'est un enum...
	public final static int INDENT_ALL = 0
	public final static int INDENT_FOR = 1
	public final static int INDENT_WHILE = 2
	public final static int INDENT_IF = 3
	public final static int INDENT_FOREACH = 4
	public final static int INDENT_DO = 5
	
	public final static Integer DEFAULT_ALL = 2
	public final static Integer DEFAULT_FOR = 0
	public final static Integer DEFAULT_WHILE = 0
	public final static Integer DEFAULT_IF = 0
	public final static Integer DEFAULT_FOREACH = 0
	public final static Integer DEFAULT_DO = 0
	
	//String des indent spécifiques à concaténer.
	String indentFor;
	String indentWhile;
	String indentIf;
	String indentForeach;
	String indentDo;
	
	int i
	
	List<Integer> indentations = new ArrayList<Integer>();
	
	 final static Map<String, Integer> DEFAULT_MAP = new HashMap<String, Integer>();
	
	//Ne sert que dans eclipse, pas dans les commande line
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		init(indentations)
		doGenerate(resource,fsa,context, "output", indentations)
	}
		
	def doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String output, List<Integer> indentations) {
		this.indentations = indentations
		calcIndent(this.indentations)
		System.out.println(indentations);
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			if(output.equals(""))
				System.out.println(e.compile())
			else fsa.generateFile(output, e.compile())
		}
	}
	
	def compile(Program p)'''
	«FOR f:p.functions»
	«f.compile»
	«ENDFOR»
	'''
	
	def compile(Function f)'''
	function «f.name» :
	«f.definition.compile»
	'''
	
	def compile(Definition d)'''
		read «FOR vr : d.read.variable SEPARATOR','»«vr»«ENDFOR»
		%
		  «d.commands.compile»
		%
		write «FOR vw : d.write.variable SEPARATOR','»«vw»«ENDFOR»
	'''
	
	def compile(Commands c)'''
	«FOR command:c.commands»
Ceci est une commande
	«ENDFOR»
	'''


	
	def static init(List<Integer> integers) {
		integers.add(INDENT_ALL,DEFAULT_ALL)
		integers.add(INDENT_FOR,DEFAULT_FOR)
		integers.add(INDENT_WHILE,DEFAULT_WHILE)
		integers.add(INDENT_IF,DEFAULT_IF)
		integers.add(INDENT_FOREACH,DEFAULT_FOREACH)
		integers.add(INDENT_DO,DEFAULT_DO)
	}
	
	//Calcule les indentations pour chaque structure de controle selon les valeurs d'indentation données
	def calcIndent(List<Integer> integers) {
		for(i = 0;i<indentations.get(INDENT_ALL);i++){
			indentFor+=" "
			indentWhile+=" "
			indentIf+=" "
			indentForeach+=" "
			indentDo+=" "
		}
		if(indentations.get(INDENT_FOR)!=0) indentFor=""
		for(i = 0;i<indentations.get(INDENT_FOR);i++)
			indentFor+=" "
		if(indentations.get(INDENT_WHILE)!=0) indentWhile=""
		for(i = 0;i<indentations.get(INDENT_WHILE);i++)
			indentWhile+=" "
		if(indentations.get(INDENT_IF)!=0) indentIf=""
		for(i = 0;i<indentations.get(INDENT_IF);i++)
			indentIf+=" "
		if(indentations.get(INDENT_FOREACH)!=0) indentForeach=""
		for(i = 0;i<indentations.get(INDENT_FOREACH);i++)
			indentForeach+=" "
		if(indentations.get(INDENT_DO)!=0) indentDo=""
		for(i = 0;i<indentations.get(INDENT_DO);i++)
			indentDo+=" "	
	}
}

